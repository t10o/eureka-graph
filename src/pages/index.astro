---
import Layout from '../layouts/Layout.astro';
import { fetchAllMonthlyData } from '../api/myslo.js';
import { 
    extractPlayGraphJsonBlocks, 
    selectTargetGraph, 
    toSeries, 
    detectCensorFlags, 
    parseActualGamesFromHtml,
    extrapolateAug31 
} from '../playgraph-utils.js';

// buildCumulative関数（累積データの作り直し）
type DayPoints = { day: string; points: { game: number; diff: number; extrapolated?: boolean }[] };

function buildCumulative(daySeries: DayPoints[]) {
    // 日付順に並べる
    const days = [...daySeries].sort((a, b) => a.day.localeCompare(b.day));

    const out: { x: number; y: number; day: string; extrapolated?: boolean }[] = [];
    let cumGame = 0;   // 累積ゲーム数（前日終端を加算）
    let offset  = 0;   // 累積差枚    （前日終端を加算）

    for (const d of days) {
        if (!d.points?.length) continue;

        // 念のため日内を昇順ソート
        d.points.sort((a,b)=>a.game-b.game);

        // 日内の先頭を0起点にそろえる（日内 diff が絶対値なら、ここで日内オフセットを引く）
        const dayBaseDiff = d.points[0].diff;
        const dayStartGame = d.points[0].game;

        for (const p of d.points) {
            const x = cumGame + (p.game - dayStartGame);      // 累積ゲーム数
            const y = offset   + (p.diff - dayBaseDiff);      // 累積差枚
            out.push({ x, y, day: d.day, extrapolated: !!p.extrapolated });
        }

        // この日の終端でオフセットを更新
        const last = d.points[d.points.length - 1];
        cumGame += last.game - dayStartGame;                 // 今日ぶんを加算
        offset  += last.diff - dayBaseDiff;                  // 今日ぶんを加算
    }

    // 縦軸のゼロ基準（最古を0）
    const base = out[0]?.y ?? 0;
    for (const p of out) p.y -= base;

    // x・y の不正＆重複 x を除去
    const seen = new Set<number>();
    const clean: typeof out = [];
    for (const p of out) {
        if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
        const k = +p.x.toFixed(6);
        if (seen.has(k)) continue;
        seen.add(k);
        clean.push(p);
    }
    // 念のため昇順
    clean.sort((a,b)=>a.x-b.x);
    return clean;
}

// ビルド時にデータを取得
let chartData: any = null;
let points: any[] = [];
let summaries: any[] = [];

try {
    // 全月次データを取得
    const monthlyData = await fetchAllMonthlyData();
    
    // 各月のHTMLを処理して日別データを生成
    const daySeriesData = [];
    const summariesData = [];
    const dayOrder = [];
    
    for (const monthData of monthlyData) {
        // 月次データから日付を生成（仮想的な日付）
        const dateStr = monthData.date.toISOString().split('T')[0];
        
        // HTMLを処理
        const html = monthData.html;
        
        try {
            // PlayGraphデータを抽出
            const blocks = extractPlayGraphJsonBlocks(html);
            if (blocks.length === 0) {
                console.warn(`No PlayGraph data found for: ${dateStr}`);
                continue;
            }
            
            // 対象グラフを選択
            const targetGraph = selectTargetGraph(blocks);
            if (!targetGraph) {
                console.warn(`No valid target graph found for: ${dateStr}`);
                continue;
            }
            
            // 実ゲーム数を抽出
            const actualGames = parseActualGamesFromHtml(html);
            
            // SeriesPointに変換（実ゲーム数に合わせて再スケール）
            let series = toSeries(targetGraph, actualGames);
            
            // 検閲フラグを検出
            const censorFlags = detectCensorFlags(targetGraph, series, actualGames);
            
            // 8/31の特別扱い
            let specialRuleApplied = false;
            let extrapolatedPointsCount = 0;
            
            if (dateStr === '2024-08-31') {
                series = extrapolateAug31(series, 10073, -3000, 50);
                specialRuleApplied = true;
                extrapolatedPointsCount = series.filter(p => p.extrapolated).length;
            }
            
            // 日別データを追加
            const points = series.map(s => ({
                game: s.game,
                diff: s.diff,
                extrapolated: s.extrapolated
            }));
            daySeriesData.push({ day: dateStr, points });
            
            // サマリを作成
            const lastPoint = series[series.length - 1];
            const summary = {
                day: dateStr,
                lastDiff: lastPoint.diff,
                actualGames,
                censoredRight: censorFlags.censoredRight,
                censoredBottom: censorFlags.censoredBottom,
                specialRuleApplied,
                extrapolatedPointsCount,
                isCensoredRight: actualGames ? actualGames > 8000 && lastPoint.game < actualGames * 0.9 : false
            };
            summariesData.push(summary);
            dayOrder.push(dateStr);
            
        } catch (error) {
            console.error(`Error processing ${dateStr}:`, error);
        }
    }
    
    // 日付順にソート
    dayOrder.sort();
    summariesData.sort((a, b) => a.day.localeCompare(b.day));
    
    // buildCumulative関数で累積データを生成
    points = buildCumulative(daySeriesData);
    
    // データ監査
    for (let i = 1; i < points.length; i++) {
        if (points[i].x < points[i-1].x) {
            throw new Error(`xが後退: idx=${i} ${points[i-1].x} -> ${points[i].x}`);
        }
    }
    console.log("OK: xは単調増加。最終x=", points.at(-1)?.x, "最終y=", points.at(-1)?.y);
    
    // X軸の最大値を2000の倍数に丸める
    const maxX = Math.ceil((points.at(-1)?.x ?? 0) / 2000) * 2000;
    
    // Chart.js用のデータ形式に変換
    chartData = {
        datasets: [{
            label: "累積収支",
            data: points,               // {x, y, day, extrapolated?}
            parsing: false,             // x/y をそのまま使う
            showLine: true,             // 点だけになるのを防ぐ
            borderWidth: 2,
            pointRadius: 1.5,
            pointHoverRadius: 2,
            fill: false,
            segment: {
                // 外挿区間だけ破線
                borderDash: (ctx: any) => {
                    const a = ctx.p0?.raw as any, b = ctx.p1?.raw as any;
                    return (a?.extrapolated || b?.extrapolated) ? [6,4] : undefined;
                }
            }
        }],
        maxX: maxX
    };
    
    summaries = summariesData;
    
} catch (error) {
    console.error('Error generating chart data:', error);
    chartData = null;
    points = [];
    summaries = [];
}
---

<Layout title="マイスロ通算グラフ">
	<div class="dashboard">
		<div class="container">
			<div class="hero">
				<h2 class="hero-title">📊 通算データ分析</h2>
				<p class="hero-description">2023年12月から現在までの実戦データを可視化</p>
			</div>
			
			{chartData ? (
				<div id="graph-container" class="graph-container">
					<div class="graph-header">
						<h3 class="graph-title">📈 累積収支グラフ</h3>
						<div class="graph-legend">
							<div class="legend-item">
								<div class="legend-color real"></div>
								<span>実データ</span>
							</div>
							<div class="legend-item">
								<div class="legend-color extrapolated"></div>
								<span>外挿データ（8/31）</span>
							</div>
						</div>
					</div>
					<div class="graph-wrapper">
						<canvas id="cumulative_graph" width="800" height="400"></canvas>
					</div>
					
					<div id="stats" class="stats-container">
						<h3 class="stats-title">📋 統計情報</h3>
						<div id="stats-content" class="stats-grid">
							{points.length > 0 && (
								<>
									<div class="stat-item">
										<span class="stat-label">総ゲーム数</span>
										<span class="stat-value">{points[points.length - 1]?.x?.toLocaleString()}G</span>
									</div>
									<div class="stat-item">
										<span class="stat-label">総収支（正規化後）</span>
										<span class="stat-value">{points[points.length - 1]?.y?.toLocaleString()}枚</span>
									</div>
									<div class="stat-item">
										<span class="stat-label">データポイント数</span>
										<span class="stat-value">{points.length}個</span>
									</div>
									{summaries.find(s => s.day === '2024-08-31' && s.specialRuleApplied) && (
										<div class="stat-item">
											<span class="stat-label">8/31外挿ポイント</span>
											<span class="stat-value">{summaries.find(s => s.day === '2024-08-31')?.extrapolatedPointsCount}個</span>
										</div>
									)}
								</>
							)}
						</div>
					</div>
				</div>
			) : (
				<div class="error-state">
					<div class="error-icon">⚠️</div>
					<h3 class="error-title">データの読み込みに失敗しました</h3>
					<p class="error-description">データの取得または処理中にエラーが発生しました</p>
				</div>
			)}
		</div>
	</div>
</Layout>

<style>
	.dashboard {
		min-height: calc(100vh - 200px);
	}

	.hero {
		text-align: center;
		margin-bottom: 3rem;
		padding: 2rem 0;
	}

	.hero-title {
		font-size: 2.5rem;
		font-weight: 700;
		color: #1f2937;
		margin: 0 0 1rem 0;
	}

	.hero-description {
		font-size: 1.2rem;
		color: #6b7280;
		margin: 0;
	}

	.loading-state {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		padding: 4rem 2rem;
		background: #ffffff;
		border: 1px solid #e5e7eb;
		border-radius: 8px;
		box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
	}

	.loading-spinner {
		width: 40px;
		height: 40px;
		border: 4px solid #e5e7eb;
		border-top: 4px solid #3b82f6;
		border-radius: 50%;
		animation: spin 1s linear infinite;
		margin-bottom: 1rem;
	}

	@keyframes spin {
		0% { transform: rotate(0deg); }
		100% { transform: rotate(360deg); }
	}

	.loading-text {
		font-size: 1.1rem;
		color: #6b7280;
		margin: 0;
	}

	.graph-container {
		background: #ffffff;
		border: 1px solid #e5e7eb;
		border-radius: 8px;
		box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
		overflow: hidden;
	}

	.graph-header {
		padding: 1.5rem;
		border-bottom: 1px solid #e5e7eb;
		display: flex;
		justify-content: space-between;
		align-items: center;
		flex-wrap: wrap;
		gap: 1rem;
	}

	.graph-title {
		font-size: 1.25rem;
		font-weight: 600;
		color: #1f2937;
		margin: 0;
	}

	.graph-legend {
		display: flex;
		gap: 1.5rem;
		flex-wrap: wrap;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.875rem;
		color: #6b7280;
	}

	.legend-color {
		width: 12px;
		height: 12px;
		border-radius: 2px;
	}

	.legend-color.real {
		background: #ef4444;
	}

	.legend-color.extrapolated {
		background: repeating-linear-gradient(
			45deg,
			#ef4444,
			#ef4444 4px,
			transparent 4px,
			transparent 8px
		);
	}

	.graph-wrapper {
		padding: 1.5rem;
		background: white;
	}

	.graph-wrapper canvas {
		width: 100%;
		height: auto;
		border-radius: 4px;
	}

	.stats-container {
		padding: 1.5rem;
		background: #f9fafb;
		border-top: 1px solid #e5e7eb;
	}

	.stats-title {
		font-size: 1.125rem;
		font-weight: 600;
		color: #1f2937;
		margin: 0 0 1rem 0;
	}

	.stats-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
		gap: 1rem;
	}

	.stat-item {
		background: white;
		padding: 1rem;
		border-radius: 6px;
		border: 1px solid #e5e7eb;
	}

	.stat-label {
		font-weight: 500;
		color: #6b7280;
		font-size: 0.875rem;
		margin-bottom: 0.25rem;
		display: block;
	}

	.stat-value {
		font-size: 1.25rem;
		font-weight: 600;
		color: #1f2937;
		margin: 0;
	}

	.error-state {
		text-align: center;
		padding: 3rem 2rem;
		background: #ffffff;
		border: 1px solid #e5e7eb;
		border-radius: 8px;
		box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
	}

	.error-icon {
		font-size: 2rem;
		margin-bottom: 1rem;
	}

	.error-title {
		font-size: 1.25rem;
		font-weight: 600;
		color: #ef4444;
		margin: 0 0 0.5rem 0;
	}

	.error-description {
		color: #6b7280;
		margin: 0;
	}

	@media (max-width: 768px) {
		.hero-title {
			font-size: 2rem;
		}
		
		.hero-description {
			font-size: 1rem;
		}
		
		.graph-header {
			flex-direction: column;
			align-items: flex-start;
			padding: 1.5rem;
		}
		
		.graph-wrapper {
			padding: 1rem;
		}
		
		.stats-container {
			padding: 1.5rem;
		}
		
		.stats-grid {
			grid-template-columns: 1fr;
		}
	}
</style>

<script define:vars={{ chartData, points, summaries }}>
    // Chart.jsのスクリプトを読み込み
    const chartScript = document.createElement('script');
    chartScript.src = 'https://cdn.jsdelivr.net/npm/chart.js';
    document.head.appendChild(chartScript);
    
    chartScript.onload = () => {
        if (chartData && chartData.datasets) {
            // Chart.jsでグラフを描画
            const canvas = document.getElementById('cumulative_graph');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            const maxX = chartData.maxX;
            
            new Chart(ctx, {
                type: "line",
                data: {
                    datasets: chartData.datasets
                },
                options: {
                    parsing: false,
                    spanGaps: false,              // null で線を切る場合は false のまま
                    plugins: { legend: { display: true } },
                    scales: {
                        x: {
                            type: "linear",
                            min: 0,
                            max: maxX,
                            ticks: { stepSize: 2000, callback: (v) => `${v}G` },
                            title: { display: true, text: "ゲーム数 (G)" },
                        },
                        y: {
                            title: { display: true, text: "累積差枚 (枚)" },
                        }
                    }
                }
            });
        }
    };
    
    chartScript.onerror = () => {
        console.error('Failed to load Chart.js script');
    };
</script>